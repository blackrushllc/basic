#![allow(dead_code)]

// This include is generated by build.rs
include!(concat!(env!("OUT_DIR"), "/embedded_includes.rs"));

use std::fs;
use std::path::{Path, PathBuf};

pub fn list_all_paths() -> impl Iterator<Item = &'static str> {
    EMBEDDED_FILES.iter().map(|f| f.path)
}

pub fn list_top_level_dirs() -> Vec<&'static str> {
    let mut dirs = Vec::new();
    for p in list_all_paths() {
        if let Some((first, _rest)) = p.split_once('/') {
            if !dirs.contains(&first) {
                dirs.push(first);
            }
        }
    }
    dirs
}

pub fn find_file(logical: &str) -> Option<&'static EmbeddedFile> {
    let logical = normalize_target(logical);
    if let Some(f) = EMBEDDED_FILES.iter().find(|f| f.path == logical) {
        return Some(f);
    }
    // convenience: try "<name>.bas" for bare names like "upgrade"
    let fallback = format!("{logical}.bas");
    EMBEDDED_FILES.iter().find(|f| f.path == fallback)
}

pub fn has_dir(dir: &str) -> bool {
    let dir = normalize_target(dir);
    let prefix = ensure_trailing_slash(&dir);
    EMBEDDED_FILES.iter().any(|f| f.path.starts_with(&prefix))
}

pub fn write_single(logical: &str, dest_root: &Path) -> std::io::Result<PathBuf> {
    let file = find_file(logical).ok_or_else(|| not_found(logical))?;
    let out = resolved_output_path_for_file(logical, dest_root);
    if let Some(parent) = out.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(&out, file.contents)?;
    Ok(out)
}

pub fn extract_dir(dir: &str, dest_root: &Path) -> std::io::Result<()> {
    let dir = normalize_target(dir);
    let prefix = ensure_trailing_slash(&dir);
    let mut found_any = false;
    for f in EMBEDDED_FILES.iter() {
        if f.path.starts_with(&prefix) {
            found_any = true;
            let rel = &f.path[prefix.len()..]; // e.g. "hello.bas"
            let out = join_forward_slash(dest_root, &dir, rel);
            if let Some(parent) = out.parent() {
                fs::create_dir_all(parent)?;
            }
            fs::write(&out, f.contents)?;
        }
    }
    if !found_any {
        return Err(not_found(&dir));
    }
    Ok(())
}

fn not_found(name: &str) -> std::io::Error {
    std::io::Error::new(std::io::ErrorKind::NotFound, format!("No embedded entry {name:?}"))
}

fn ensure_trailing_slash(s: &str) -> String {
    if s.ends_with('/') { s.to_string() } else { format!("{s}/") }
}

fn resolved_output_path_for_file(logical: &str, dest_root: &Path) -> PathBuf {
    // If logical contains a '/', treat as relative path under CWD.
    // If bare name like "upgrade", write "<cwd>/upgrade.bas".
    let logical = normalize_target(logical);
    if logical.contains('/') || logical.ends_with(".bas") {
        join_forward_slash(dest_root, "", &logical)
    } else {
        dest_root.join(format!("{logical}.bas"))
    }
}

pub fn is_unsafe_target(target: &str) -> bool {
    let p = target.replace('\\', "/");
    Path::new(&p).is_absolute() || p.contains("..")
}

fn normalize_target(s: &str) -> String {
    s.replace('\\', "/").trim_start_matches("./").to_string()
}

fn join_forward_slash(root: &Path, mid: &str, rel: &str) -> PathBuf {
    // Join rel components split by '/'
    let mut pb = PathBuf::from(root);
    if !mid.is_empty() { for part in mid.split('/') { if !part.is_empty() { pb.push(part); } } }
    for part in rel.split('/') { if !part.is_empty() { pb.push(part); } }
    pb
}
